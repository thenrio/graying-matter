title: Agile Open France 2011
slug: agile-open-france-2011

Agile Open matters for at least two reasons

* it is a place to live with people and share thoughts
* it is a place where you can experiment

Here is my notes and thoughts on what happened to me

Programming
===========
Talk is cheap, Show me the code

Agile Cup Challenge
===================
My mistakes

Code rather than form a pair
----------------------------
I wanted so much to code that I just sit on a empty table and started

So I coded alone !
 
Great moment of solitude :)
    
Pay attention to what others were doing
---------------------------------------
It was not enough to be alone : I had a pair to my left and one to my right...

Uh!, Arnaud and Xavier has all green in scala and I have only one red ?
It must be a fake ... Hu what was I doing ?

What? Perrick and Gabriel is one green in php and I'm one red ?
    
Half baked integration
----------------------
my first commit was
    
      get '/wordcloud' do
        123
      end

and see 123 as red under first test

good...

and so bad not to have get it to green with data that were on the testing page (Net::Http.get or Typhoeus::Request.new('grab').response.body)

It is a small step, and small is just as important as big

Focusless
---------
Mere look at what is to be done is not enough to have a clear vision

Blindness occurs unless clear vision

And then be trampled by SRP : my code was mixing fold and presentation responsibilities...

Jonathan showed me his code, and it was clear by difference that I had done this mistake

Kudos to @amicel who won challenge

I'm glad I made so many mistakes because I'll be better next time

Challenges like this are so fun!!

Lisp experiment : reinvent fold
===============================
Great fun!
A few keywords explained (funcall, fun, mapcar) and we can get it (with various missing ' or )) 

And a remark Arnaud made to what I did to test code : remove the scaffold

"assert 43" had no more structural value per se than "assert 42", so I removed "assert 43"

Remove it is "removing the scaffold", that is remove the scaffold that lead us to the next test

See : terminated brainf*ck interpretor in erlang
================================================
I was blown when I saw code produced by Dominic and Arnaud

Jonathan review was enlightening

When I had technical knowledge of 90% of them, there is 0% of chance I would have produced _now_ a similar code in response to the brainf*ck problem

It is not important, what is important is that code was functional :)

Assist Kata in the hat
======================
I find that Physical constraints do hardly produce good code (code with your feet, code with your nose...) 

Eat your own dog food! I will never though of doing such a thing !!

Now I find at least two great thing

* code like a plane : make arts with green code
    
* great fold by Jonathan, something like

        words.drop(1).inject(words.first) {|sentence, w| sentence << ", " << w}

    That is inject|reduce|fold __less__ prevent to have heading or trailing comma

Beyond TDD?
===========
Talk on insights generated by QuickCheck [here](http://en.wikipedia.org/wiki/QuickCheck) and [here](http://www.quviq.com/)

Principle is generate a large amount of tests based on desired properties of underlying code, then reduce failing test to have the "smallest" failing data

Just bought Arnaud's book [Pearls of Functional Algorithm Design](http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383)

I might have to learn some [haskell](http://learnyouahaskell.com/) to understand it, and still I plan to make some out of [erlang](http://learnyousomeerlang.com/)

Guillaume told us that there is such a tool for C# ... and I do not remember its name :)

Philosophy | social
===================
Beyond our beliefs
==================
I believe X is true because :

1. I trust the person that told me X is true
2. I can experiment for myself that X is true

This kind of enlightenment is what make Agile Open so great : it is not that I can not find this for myself, it is I did not find the place and time to think about it

And it is important : Trust is human (soft), experimentation scientific (hard)

So I can be harsh and cold and keen to favor hard skill, I realized that my beliefs are now more inclined to be built on soft ground

Lean
====
I was pleased to see Antoine ... there was a sticky "Mister Austere" for him ...

I was never impressed by his harshness and I prefer Mister Check

CDD (expands_to ComplaintDrivenDevelopment)
===========================================
Mister Check gave us the background that lead him to the so called CDD

Maintenance team
----------------
* responds to internal customer request (level 2 support) 
* is driven by incoming tickets
* has incentive to lower number of tickets, then they can move to project team ("more interesting" incentive)

Change vision of a ticket
-------------------------
Ticket is a Complaint of One Customer

Major transformation was to make team see incoming tickets as defects of the system, rather than some work that is to be done.
Ticket is pain, not relief.

Make categories|family and count
--------------------------------
Categories are made by team, just count them

* A : 6
* B : 28
* C : 4

Then experiment on "B"

Families are made to help solve the customer problem (as opposed to being a technical solution)

Laurent M. gave an enlightening feedback : CDD is an implementation of PDD in the above context

Segregation was not a theme in PDD, I believe, and it is not important : Goals are the same, that is what matters

Experiment
----------
Measure "B", and draw conclusions then knowledge

Red Bins
========
Goal was to discover visual artifacts for presenting "Defect" on the board

I suffer from limitations to present visual with text... so here is mere text

Visualize
---------

* red dot when team member has issue with item
* small sticky describing nature of issue
* dot|stripe on item to indicate age, and then red if too old (lead time policy, Antoine)
* ok | ko for each item of release (Antoine)
* red bin, and item go to bin when one of its check list is false

Segregate
---------
After release, count

* dots
* make families, with the help of small stickies, and reduce list on each family
* experiment for all families, begin with high scoring

Rinse, Repeat

The most important

1. measure
2. __CHECK__

Locations for Red Bins ?
------------------------
Located above "Check List" (aka DoD) of each stage, Red Bin is there to ask us : "Can we make a modification to this list, or to one in upper process ?"

Have explicit policy : 

* eg : Item in Red Bin have higher priority than other, still keep on item being worked on

PISCAR
======

* P(roblem)
    must have
      * customer
      * gap with standard
      * a measure
      
* I(mpact)
    must have
      * reverse logical connection with problem
      * a conversion in cash (at least possible)
      * how does problem affect enterprise strategy and goals ?
      
* S(tandard)
* C(auses)
* A(ction)
      must have
        * an experimental protocol to CHECK cause

* (planned) R(esult)

PISCAR is P of PDCA on steroids


Thank to all of participants, for being there and having created this space where very live things happens
